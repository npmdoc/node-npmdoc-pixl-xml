<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/jhuckaby/pixl-xml"

    >pixl-xml (v1.0.10)</a>
</h1>
<h4>A simple module for parsing and composing XML.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.pixl-xml">module pixl-xml</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser">
            function <span class="apidocSignatureSpan">pixl-xml.</span>Parser
            <span class="apidocSignatureSpan">(args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.XML">
            function <span class="apidocSignatureSpan">pixl-xml.</span>XML
            <span class="apidocSignatureSpan">(args, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.alwaysArray">
            function <span class="apidocSignatureSpan">pixl-xml.</span>alwaysArray
            <span class="apidocSignatureSpan">(obj, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.decodeEntities">
            function <span class="apidocSignatureSpan">pixl-xml.</span>decodeEntities
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.encodeAttribEntities">
            function <span class="apidocSignatureSpan">pixl-xml.</span>encodeAttribEntities
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.encodeEntities">
            function <span class="apidocSignatureSpan">pixl-xml.</span>encodeEntities
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.firstKey">
            function <span class="apidocSignatureSpan">pixl-xml.</span>firstKey
            <span class="apidocSignatureSpan">(hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.hashKeysToArray">
            function <span class="apidocSignatureSpan">pixl-xml.</span>hashKeysToArray
            <span class="apidocSignatureSpan">(hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.isaArray">
            function <span class="apidocSignatureSpan">pixl-xml.</span>isaArray
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.isaHash">
            function <span class="apidocSignatureSpan">pixl-xml.</span>isaHash
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.numKeys">
            function <span class="apidocSignatureSpan">pixl-xml.</span>numKeys
            <span class="apidocSignatureSpan">(hash)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.parse">
            function <span class="apidocSignatureSpan">pixl-xml.</span>parse
            <span class="apidocSignatureSpan">(text, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.stringify">
            function <span class="apidocSignatureSpan">pixl-xml.</span>stringify
            <span class="apidocSignatureSpan">(node, name, indent, indent_string, eol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.trim">
            function <span class="apidocSignatureSpan">pixl-xml.</span>trim
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.</span>Parser.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pixl-xml.Parser">module pixl-xml.Parser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.Parser">
            function <span class="apidocSignatureSpan">pixl-xml.</span>Parser
            <span class="apidocSignatureSpan">(args, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pixl-xml.Parser.prototype">module pixl-xml.Parser.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>lowerCase</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>preserveAttributes</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>preserveDocumentNode</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.compose">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>compose
            <span class="apidocSignatureSpan">(indent_string, eol)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.error">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>error
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.getError">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>getError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.getLastError">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>getLastError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.getTree">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>getTree
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.parse">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parse
            <span class="apidocSignatureSpan">(branch, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.parseCDATANode">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parseCDATANode
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.parseCommentNode">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parseCommentNode
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.parseDTDNode">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parseDTDNode
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.parsePINode">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parsePINode
            <span class="apidocSignatureSpan">(tag)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pixl-xml.Parser.prototype.throwParseError">
            function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>throwParseError
            <span class="apidocSignatureSpan">(key, tag)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patAttrib</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patCDATANode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patCDATATag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patCommentTag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patDTDNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patDTDTag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patEndCDATA</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patEndComment</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patEndDTD</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patExternalDTDNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patInlineDTDNode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patNextClose</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patPINode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patPITag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patSelfClosing</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patSpecialTag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patStandardTag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>patTag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>attribsKey</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>dataKey</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pixl-xml" id="apidoc.module.pixl-xml">module pixl-xml</a></h1>


    <h2>
        <a href="#apidoc.element.pixl-xml.Parser" id="apidoc.element.pixl-xml.Parser">
        function <span class="apidocSignatureSpan">pixl-xml.</span>Parser
        <span class="apidocSignatureSpan">(args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XML(args, opts) {
	// class constructor for XML parser class
	// pass in args hash or text to parse
	if (!args) args = &#x27;&#x27;;
	if (isa_hash(args)) {
		for (var key in args) this[key] = args[key];
	}
	else this.text = args || &#x27;&#x27;;
	
	// options may be 2nd argument as well
	if (opts) {
		for (var key in opts) this[key] = opts[key];
	}
	
	// stringify buffers
	if (this.text instanceof Buffer) {
		this.text = this.text.toString();
	}
	
	if (!this.text.match(/^\s*&#x3c;/)) {
		// try as file path
		var file = this.text;
		this.text = fs.readFileSync(file, { encoding: &#x27;utf8&#x27; });
		if (!this.text) throw new Error(&#x22;File not found: &#x22; + file);
	}
	
	this.tree = {};
	this.errors = [];
	this.piNodeList = [];
	this.dtdNodeList = [];
	this.documentNodeName = &#x27;&#x27;;
	
	if (this.lowerCase) {
		this.attribsKey = this.attribsKey.toLowerCase();
		this.dataKey = this.dataKey.toLowerCase();
	}
	
	this.patTag.lastIndex = 0;
	if (this.text) this.parse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var xml_string = &#x27;&#x3c;?xml version=&#x22;1.0&#x22; encoding=&#x22;UTF-8&#x22;?&#x3e;&#x3c;Document&#x3e;&#x27; +
	&#x27;&#x3c;Simple&#x3e;Hello&#x3c;/Simple&#x3e;&#x27; +
	&#x27;&#x3c;Node Key=&#x22;Value&#x22;&#x3e;Complex&#x3c;/Node&#x3e;&#x27; +
	&#x27;&#x3c;/Document&#x3e;&#x27;;

var parser = null;
try {
	parser = new XML.<span class="apidocCodeKeywordSpan">Parser</span>( xml_string, { preserveAttributes: true } );
}
catch (err) {
	throw err;
}

var doc = parser.getTree();
doc.Simple = &#x22;Hello, I changed this.&#x22;;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.XML" id="apidoc.element.pixl-xml.XML">
        function <span class="apidocSignatureSpan">pixl-xml.</span>XML
        <span class="apidocSignatureSpan">(args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XML(args, opts) {
	// class constructor for XML parser class
	// pass in args hash or text to parse
	if (!args) args = &#x27;&#x27;;
	if (isa_hash(args)) {
		for (var key in args) this[key] = args[key];
	}
	else this.text = args || &#x27;&#x27;;
	
	// options may be 2nd argument as well
	if (opts) {
		for (var key in opts) this[key] = opts[key];
	}
	
	// stringify buffers
	if (this.text instanceof Buffer) {
		this.text = this.text.toString();
	}
	
	if (!this.text.match(/^\s*&#x3c;/)) {
		// try as file path
		var file = this.text;
		this.text = fs.readFileSync(file, { encoding: &#x27;utf8&#x27; });
		if (!this.text) throw new Error(&#x22;File not found: &#x22; + file);
	}
	
	this.tree = {};
	this.errors = [];
	this.piNodeList = [];
	this.dtdNodeList = [];
	this.documentNodeName = &#x27;&#x27;;
	
	if (this.lowerCase) {
		this.attribsKey = this.attribsKey.toLowerCase();
		this.dataKey = this.dataKey.toLowerCase();
	}
	
	this.patTag.lastIndex = 0;
	if (this.text) this.parse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.alwaysArray" id="apidoc.element.pixl-xml.alwaysArray">
        function <span class="apidocSignatureSpan">pixl-xml.</span>alwaysArray
        <span class="apidocSignatureSpan">(obj, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function always_array(obj, key) {
	// if object is not array, return array containing object
	// if key is passed, work like XMLalwaysarray() instead
	if (key) {
		if ((typeof(obj[key]) != &#x27;object&#x27;) || (typeof(obj[key].length) == &#x27;undefined&#x27;)) {
			var temp = obj[key];
			delete obj[key];
			obj[key] = new Array();
			obj[key][0] = temp;
		}
		return null;
	}
	else {
		if ((typeof(obj) != &#x27;object&#x27;) || (typeof(obj.length) == &#x27;undefined&#x27;)) { return [ obj ]; }
		else return obj;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```
ARRAY alwaysArray( MIXED )
```

This function will wrap anything passed to it into an array and return the array, unless the item passed is already an array, in
 which case it is simply returned verbatim.

```javascript
var arr = XML.<span class="apidocCodeKeywordSpan">alwaysArray</span>( maybe_array );
```

## hashKeysToArray

```
ARRAY hashKeysToArray( OBJECT )
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.decodeEntities" id="apidoc.element.pixl-xml.decodeEntities">
        function <span class="apidocSignatureSpan">pixl-xml.</span>decodeEntities
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function decode_entities(text) {
	// Decode XML entities into raw ASCII
	if (text == null) return &#x27;&#x27;;
	
	if (text &#x26;&#x26; text.replace &#x26;&#x26; text.match(/\&#x26;/)) {
		text = text.replace(/\&#x26;lt\;/g, &#x22;&#x3c;&#x22;);
		text = text.replace(/\&#x26;gt\;/g, &#x22;&#x3e;&#x22;);
		text = text.replace(/\&#x26;quot\;/g, &#x27;&#x22;&#x27;);
		text = text.replace(/\&#x26;apos\;/g, &#x22;&#x27;&#x22;);
		text = text.replace(/\&#x26;amp\;/g, &#x22;&#x26;&#x22;); // MUST BE LAST
	}
	
	return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
STRING decodeEntities( STRING )
```

This function decodes all the standard XML entities back into their original characters.  This includes ampersand (`&#x26;`), left
-angle-bracket (`&#x3c;`), right-angle-bracket (`&#x3e;`), single-quote (`&#x27;`) and double-quote (`&#x22;`).  It is used when
 parsing XML element and attribute values.  Example:

```javascript
var text = &#x27;&#x26;lt;Hello&#x26;gt;&#x26;quot;&#x26;amp;&#x26;quot;&#x26;lt;There&#x26;gt;&#x27;;
console.log( XML.<span class="apidocCodeKeywordSpan">decodeEntities</span>(text) );
// Would output: &#x3c;Hello&#x3e;&#x22;&#x26;&#x22;&#x3c;There&#x3e;
```

## alwaysArray

```
ARRAY alwaysArray( MIXED )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.encodeAttribEntities" id="apidoc.element.pixl-xml.encodeAttribEntities">
        function <span class="apidocSignatureSpan">pixl-xml.</span>encodeAttribEntities
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode_attrib_entities(text) {
	// Simple entitize exports.for = function for composing XML attributes
	if (text == null) return &#x27;&#x27;;
	
	if (text &#x26;&#x26; text.replace) {
		text = text.replace(/\&#x26;/g, &#x22;&#x26;amp;&#x22;); // MUST BE FIRST
		text = text.replace(/&#x3c;/g, &#x22;&#x26;lt;&#x22;);
		text = text.replace(/&#x3e;/g, &#x22;&#x26;gt;&#x22;);
		text = text.replace(/\&#x22;/g, &#x22;&#x26;quot;&#x22;);
		text = text.replace(/\&#x27;/g, &#x22;&#x26;apos;&#x22;);
	}
	
	return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
STRING encodeAttribEntities( STRING )
```

This function does basically the same thing as [encodeEntities](#encodeentities), but it also includes encoding for single-quotes
 (`&#x27;`) and double-quotes (`&#x22;`).  It is used for encoding an XML string for composing into an attribute value.  It returns
 the result.  Example:

```javascript
var text = &#x27;&#x3c;Hello&#x3e;&#x22;&#x26;&#x22;&#x3c;There&#x3e;&#x27;;
console.log( XML.<span class="apidocCodeKeywordSpan">encodeAttribEntities</span>(text) );
// Would output: &#x26;lt;Hello&#x26;gt;&#x26;quot;&#x26;amp;&#x26;quot;&#x26;lt;There&#x26;gt;
```

## decodeEntities

```
STRING decodeEntities( STRING )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.encodeEntities" id="apidoc.element.pixl-xml.encodeEntities">
        function <span class="apidocSignatureSpan">pixl-xml.</span>encodeEntities
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function encode_entities(text) {
	// Simple entitize exports.for = function for composing XML
	if (text == null) return &#x27;&#x27;;
	
	if (text &#x26;&#x26; text.replace) {
		text = text.replace(/\&#x26;/g, &#x22;&#x26;amp;&#x22;); // MUST BE FIRST
		text = text.replace(/&#x3c;/g, &#x22;&#x26;lt;&#x22;);
		text = text.replace(/&#x3e;/g, &#x22;&#x26;gt;&#x22;);
	}
	
	return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
STRING encodeEntities( STRING )
```

This function will take a string, and encode the three standard XML entities, ampersand (`&#x26;`), left-angle-bracket (`&#x3c;`)
and right-angle-bracket (`&#x3e;`), into their XML-safe counterparts.  It returns the result.  Example:

```javascript
var text = &#x27;&#x3c;Hello&#x3e;&#x26;&#x3c;There&#x3e;&#x27;;
console.log( XML.<span class="apidocCodeKeywordSpan">encodeEntities</span>(text) );
// Would output: &#x26;lt;Hello&#x26;gt;&#x26;amp;&#x26;lt;There&#x26;gt;
```

## encodeAttribEntities

```
STRING encodeAttribEntities( STRING )
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.firstKey" id="apidoc.element.pixl-xml.firstKey">
        function <span class="apidocSignatureSpan">pixl-xml.</span>firstKey
        <span class="apidocSignatureSpan">(hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function first_key(hash) {
	// return first key from hash (unordered)
	for (var key in hash) return key;
	return null; // no keys in hash
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
STRING firstKey( OBJECT )
```

This function returns the first key of the hash when iterating over it.  Note that hash keys are stored in an undefined order.

```javascript
var my_hash = { foo: &#x22;bar&#x22;, baz: 12345 };
var key = XML.<span class="apidocCodeKeywordSpan">firstKey</span>( my_hash ); // foo or baz
```

# Known Issues

* Serialized XML doesn&#x27;t exactly match parsed XML.
* Unicode XML entities are not decoded when parsed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.hashKeysToArray" id="apidoc.element.pixl-xml.hashKeysToArray">
        function <span class="apidocSignatureSpan">pixl-xml.</span>hashKeysToArray
        <span class="apidocSignatureSpan">(hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hash_keys_to_array(hash) {
	// convert hash keys to array (discard values)
	var array = [];
	for (var key in hash) array.push(key);
	return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
ARRAY hashKeysToArray( OBJECT )
```

This function returns all the hash keys as an array.  Useful for sorting and then iterating over the sorted list.

```javascript
var my_hash = { foo: &#x22;bar&#x22;, baz: 12345 };
var keys = XML.<span class="apidocCodeKeywordSpan">hashKeysToArray</span>( my_hash ).sort();

for (var idx = 0, len = keys.length; idx &#x3c; len; idx++) {
	var key = keys[idx];
	// do something with key and my_hash[key]
}
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.isaArray" id="apidoc.element.pixl-xml.isaArray">
        function <span class="apidocSignatureSpan">pixl-xml.</span>isaArray
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isa_array(arg) {
	// determine if arg is an array or is array-like
	return isArray(arg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BOOLEAN isaArray( MIXED )
```

This function returns `true` if the provided argument is an array (or is array-like), `false` otherwise.

```javascript
var my_arr = [ &#x22;foo&#x22;, &#x22;bar&#x22;, 12345 ];
var is_arr = XML.<span class="apidocCodeKeywordSpan">isaArray</span>( my_arr );
```

## numKeys

```
INTEGER numKeys( OBJECT )
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.isaHash" id="apidoc.element.pixl-xml.isaHash">
        function <span class="apidocSignatureSpan">pixl-xml.</span>isaHash
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isa_hash(arg) {
	// determine if arg is a hash
	return( !!arg &#x26;&#x26; (typeof(arg) == &#x27;object&#x27;) &#x26;&#x26; !isa_array(arg) );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
BOOLEAN isaHash( MIXED )
```

This function returns `true` if the provided argument is a hash (object), `false` otherwise.

```javascript
var my_hash = { foo: &#x22;bar&#x22;, baz: 12345 };
var is_hash = XML.<span class="apidocCodeKeywordSpan">isaHash</span>( my_hash );
```

## isaArray

```
BOOLEAN isaArray( MIXED )
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.numKeys" id="apidoc.element.pixl-xml.numKeys">
        function <span class="apidocSignatureSpan">pixl-xml.</span>numKeys
        <span class="apidocSignatureSpan">(hash)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function num_keys(hash) {
	// count the number of keys in a hash
	var count = 0;
	for (var a in hash) count++;
	return count;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
INTEGER numKeys( OBJECT )
```

This function returns the number of keys in the specified hash.

```javascript
var my_hash = { foo: &#x22;bar&#x22;, baz: 12345 };
var num = XML.<span class="apidocCodeKeywordSpan">numKeys</span>( my_hash ); // 2
```

## firstKey

```
STRING firstKey( OBJECT )
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.parse" id="apidoc.element.pixl-xml.parse">
        function <span class="apidocSignatureSpan">pixl-xml.</span>parse
        <span class="apidocSignatureSpan">(text, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse_xml(text, opts) {
	// turn text into XML tree quickly
	if (!opts) opts = {};
	opts.text = text;
	var parser = new XML(opts);
	return parser.error() ? parser.getLastError() : parser.getTree();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var XML = require(&#x27;pixl-xml&#x27;);
```

# Simplified API

The simplified API provides basic `XML.<span class="apidocCodeKeywordSpan">parse</span>()` and `XML.stringify()` standalone functions
 for parsing and serializing XML.  Also see the [Object-Oriented API](#object-oriented-api) below, for more control over your XML
.

Parse some XML by passing a string to `XML.parse()`:

```javascript
var xml_string = &#x27;&#x3c;?xml version=&#x22;1.0&#x22;?&#x3e;&#x3c;Document&#x3e;&#x27; +
	&#x27;&#x3c;Simple&#x3e;Hello&#x3c;/Simple&#x3e;&#x27; +
	&#x27;&#x3c;Node Key=&#x22;Value&#x22;&#x3e;Complex&#x3c;/Node&#x3e;&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.stringify" id="apidoc.element.pixl-xml.stringify">
        function <span class="apidocSignatureSpan">pixl-xml.</span>stringify
        <span class="apidocSignatureSpan">(node, name, indent, indent_string, eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compose_xml(node, name, indent, indent_string, eol) {
	// Compose node into XML including attributes
	// Recurse for child nodes
	if (typeof(indent_string) == &#x27;undefined&#x27;) indent_string = &#x22;\t&#x22;;
	if (typeof(eol) == &#x27;undefined&#x27;) eol = &#x22;\n&#x22;;
	var xml = &#x22;&#x22;;
	
	// If this is the root node, set the indent to 0
	// and setup the XML header (PI node)
	if (!indent) {
		indent = 0;
		xml = xml_header + eol;
		
		if (!name) {
			// no name provided, assume content is wrapped in it
			name = first_key(node);
			node = node[name];
		}
	}
	
	// Setup the indent text
	var indent_text = &#x22;&#x22;;
	for (var k = 0; k &#x3c; indent; k++) indent_text += indent_string;
	
	if ((typeof(node) == &#x27;object&#x27;) &#x26;&#x26; (node != null)) {
		// node is object -- now see if it is an array or hash
		if (!node.length) { // what about zero-length array?
			// node is hash
			xml += indent_text + &#x22;&#x3c;&#x22; + name;
			
			var num_keys = 0;
			var has_attribs = 0;
			for (var key in node) num_keys++; // there must be a better way...
			
			if (node[&#x22;_Attribs&#x22;]) {
				has_attribs = 1;
				var sorted_keys = hash_keys_to_array(node[&#x22;_Attribs&#x22;]).sort();
				for (var idx = 0, len = sorted_keys.length; idx &#x3c; len; idx++) {
					var key = sorted_keys[idx];
					xml += &#x22; &#x22; + key + &#x22;=\&#x22;&#x22; + encode_attrib_entities(node[&#x22;_Attribs&#x22;][key]) + &#x22;\&#x22;&#x22;;
				}
			} // has attribs
			
			if (num_keys &#x3e; has_attribs) {
				// has child elements
				xml += &#x22;&#x3e;&#x22;;
				
				if (node[&#x22;_Data&#x22;]) {
					// simple text child node
					xml += encode_entities(node[&#x22;_Data&#x22;]) + &#x22;&#x3c;/&#x22; + name + &#x22;&#x3e;&#x22; + eol;
				} // just text
				else {
					xml += eol;
					
					var sorted_keys = hash_keys_to_array(node).sort();
					for (var idx = 0, len = sorted_keys.length; idx &#x3c; len; idx++) {
						var key = sorted_keys[idx];					
						if ((key != &#x22;_Attribs&#x22;) &#x26;&#x26; key.match(re_valid_tag_name)) {
							// recurse for node, with incremented indent value
							xml += compose_xml( node[key], key, indent + 1, indent_string, eol );
						} // not _Attribs key
					} // foreach key
					
					xml += indent_text + &#x22;&#x3c;/&#x22; + name + &#x22;&#x3e;&#x22; + eol;
				} // real children
			}
			else {
				// no child elements, so self-close
				xml += &#x22;/&#x3e;&#x22; + eol;
			}
		} // standard node
		else {
			// node is array
			for (var idx = 0; idx &#x3c; node.length; idx++) {
				// recurse for node in array with same indent
				xml += compose_xml( node[idx], name, indent, indent_string, eol );
			}
		} // array of nodes
	} // complex node
	else {
		// node is simple string
		xml += indent_text + &#x22;&#x3c;&#x22; + name + &#x22;&#x3e;&#x22; + encode_entities(node) + &#x22;&#x3c;/&#x22; + name + &#x22;&#x3e;&#x22; + eol;
	} // simple text node
	
	return xml;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var XML = require(&#x27;pixl-xml&#x27;);
```

# Simplified API

The simplified API provides basic `XML.parse()` and `XML.<span class="apidocCodeKeywordSpan">stringify</span>()` standalone functions
 for parsing and serializing XML.  Also see the [Object-Oriented API](#object-oriented-api) below, for more control over your XML
.

Parse some XML by passing a string to `XML.parse()`:

```javascript
var xml_string = &#x27;&#x3c;?xml version=&#x22;1.0&#x22;?&#x3e;&#x3c;Document&#x3e;&#x27; +
	&#x27;&#x3c;Simple&#x3e;Hello&#x3c;/Simple&#x3e;&#x27; +
	&#x27;&#x3c;Node Key=&#x22;Value&#x22;&#x3e;Complex&#x3c;/Node&#x3e;&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.trim" id="apidoc.element.pixl-xml.trim">
        function <span class="apidocSignatureSpan">pixl-xml.</span>trim
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trim(text) {
	// strip whitespace from beginning and end of string
	if (text == null) return &#x27;&#x27;;
	
	if (text &#x26;&#x26; text.replace) {
		text = text.replace(/^\s+/, &#x22;&#x22;);
		text = text.replace(/\s+$/, &#x22;&#x22;);
	}
	
	return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pixl-xml.Parser" id="apidoc.module.pixl-xml.Parser">module pixl-xml.Parser</a></h1>


    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.Parser" id="apidoc.element.pixl-xml.Parser.Parser">
        function <span class="apidocSignatureSpan">pixl-xml.</span>Parser
        <span class="apidocSignatureSpan">(args, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XML(args, opts) {
	// class constructor for XML parser class
	// pass in args hash or text to parse
	if (!args) args = &#x27;&#x27;;
	if (isa_hash(args)) {
		for (var key in args) this[key] = args[key];
	}
	else this.text = args || &#x27;&#x27;;
	
	// options may be 2nd argument as well
	if (opts) {
		for (var key in opts) this[key] = opts[key];
	}
	
	// stringify buffers
	if (this.text instanceof Buffer) {
		this.text = this.text.toString();
	}
	
	if (!this.text.match(/^\s*&#x3c;/)) {
		// try as file path
		var file = this.text;
		this.text = fs.readFileSync(file, { encoding: &#x27;utf8&#x27; });
		if (!this.text) throw new Error(&#x22;File not found: &#x22; + file);
	}
	
	this.tree = {};
	this.errors = [];
	this.piNodeList = [];
	this.dtdNodeList = [];
	this.documentNodeName = &#x27;&#x27;;
	
	if (this.lowerCase) {
		this.attribsKey = this.attribsKey.toLowerCase();
		this.dataKey = this.dataKey.toLowerCase();
	}
	
	this.patTag.lastIndex = 0;
	if (this.text) this.parse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var xml_string = &#x27;&#x3c;?xml version=&#x22;1.0&#x22; encoding=&#x22;UTF-8&#x22;?&#x3e;&#x3c;Document&#x3e;&#x27; +
	&#x27;&#x3c;Simple&#x3e;Hello&#x3c;/Simple&#x3e;&#x27; +
	&#x27;&#x3c;Node Key=&#x22;Value&#x22;&#x3e;Complex&#x3c;/Node&#x3e;&#x27; +
	&#x27;&#x3c;/Document&#x3e;&#x27;;

var parser = null;
try {
	parser = new XML.<span class="apidocCodeKeywordSpan">Parser</span>( xml_string, { preserveAttributes: true } );
}
catch (err) {
	throw err;
}

var doc = parser.getTree();
doc.Simple = &#x22;Hello, I changed this.&#x22;;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pixl-xml.Parser.prototype" id="apidoc.module.pixl-xml.Parser.prototype">module pixl-xml.Parser.prototype</a></h1>








    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.compose" id="apidoc.element.pixl-xml.Parser.prototype.compose">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>compose
        <span class="apidocSignatureSpan">(indent_string, eol)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compose = function (indent_string, eol) {
	// compose tree back into XML
	if (typeof(eol) == &#x27;undefined&#x27;) eol = &#x22;\n&#x22;;
	var tree = this.tree;
	if (this.preserveDocumentNode) tree = tree[this.documentNodeName];
	
	var raw = compose_xml( tree, this.documentNodeName, 0, indent_string, eol );
	var body = raw.replace(/^\s*\&#x3c;\?.+?\?\&#x3e;\s*/, &#x27;&#x27;);
	var xml = &#x27;&#x27;;
	
	if (this.piNodeList.length) {
		for (var idx = 0, len = this.piNodeList.length; idx &#x3c; len; idx++) {
			xml += &#x27;&#x3c;&#x27; + this.piNodeList[idx] + &#x27;&#x3e;&#x27; + eol;
		}
	}
	else {
		xml += xml_header + eol;
	}
	
	if (this.dtdNodeList.length) {
		for (var idx = 0, len = this.dtdNodeList.length; idx &#x3c; len; idx++) {
			xml += &#x27;&#x3c;&#x27; + this.dtdNodeList[idx] + &#x27;&#x3e;&#x27; + eol;
		}
	}
	
	xml += body;
	return xml;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
catch (err) {
	throw err;
}

var doc = parser.getTree();
doc.Simple = &#x22;Hello, I changed this.&#x22;;

console.log( parser.<span class="apidocCodeKeywordSpan">compose</span>() );
```

This would produce the following output:

```xml
&#x3c;?xml version=&#x22;1.0&#x22; encoding=&#x22;UTF-8&#x22;?&#x3e;
&#x3c;Document&#x3e;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.error" id="apidoc.element.pixl-xml.Parser.prototype.error">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>error
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function () {
	// return number of errors
	return this.errors.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
				if (this.preserveAttributes &#x26;&#x26; !num_keys(attribs)) {
					delete leaf[this.attribsKey];
				}
				
				// Recurse for nested nodes
				if (!selfClosing) {
					this.parse( leaf, nodeName );
					if (this.<span class="apidocCodeKeywordSpan">error</span>()) break;
				}
				
				// Compress into simple node if text only
				var num_leaf_keys = num_keys(leaf);
				if ((typeof(leaf[this.dataKey]) != &#x27;undefined&#x27;) &#x26;&#x26; (num_leaf_keys == 1)) {
					leaf = leaf[this.dataKey];
				}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.getError" id="apidoc.element.pixl-xml.Parser.prototype.getError">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>getError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getError = function (error) {
	// get formatted error
	var text = &#x27;&#x27;;
	if (!error) return &#x27;&#x27;;

	text = (error.type || &#x27;General&#x27;) + &#x27; Error&#x27;;
	if (error.code) text += &#x27; &#x27; + error.code;
	text += &#x27;: &#x27; + error.key;
	
	if (error.line) text += &#x27; on line &#x27; + error.line;
	if (error.text) text += &#x27;: &#x27; + error.text;

	return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

	return text;
};

XML.prototype.getLastError = function() {
	// Get most recently thrown error in plain text format
	if (!this.error()) return &#x27;&#x27;;
	return this.<span class="apidocCodeKeywordSpan">getError</span>( this.errors[this.errors.length - 1] );
};

XML.prototype.parsePINode = function(tag) {
	// Parse Processor Instruction Node, e.g. &#x3c;?xml version=&#x22;1.0&#x22;?&#x3e;
	if (!tag.match(this.patPINode)) {
		this.throwParseError( &#x22;Malformed processor instruction&#x22;, tag );
		return null;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.getLastError" id="apidoc.element.pixl-xml.Parser.prototype.getLastError">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>getLastError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getLastError = function () {
	// Get most recently thrown error in plain text format
	if (!this.error()) return &#x27;&#x27;;
	return this.getError( this.errors[this.errors.length - 1] );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		type: &#x27;Parse&#x27;,
		key: key,
		text: &#x27;&#x3c;&#x27; + tag + &#x27;&#x3e;&#x27;,
		line: lineNum
	});
	
	// Throw actual error (must wrap parse in try/catch)
	throw new Error( this.<span class="apidocCodeKeywordSpan">getLastError</span>() );
};

XML.prototype.error = function() {
	// return number of errors
	return this.errors.length;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.getTree" id="apidoc.element.pixl-xml.Parser.prototype.getTree">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>getTree
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getTree = function () {
	// get reference to parsed XML tree
	return this.tree;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
try {
	parser = new XML.Parser( xml_string, { preserveAttributes: true } );
}
catch (err) {
	throw err;
}

var doc = parser.<span class="apidocCodeKeywordSpan">getTree</span>();
doc.Simple = &#x22;Hello, I changed this.&#x22;;

console.log( parser.compose() );
```

This would produce the following output:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.parse" id="apidoc.element.pixl-xml.Parser.prototype.parse">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parse
        <span class="apidocSignatureSpan">(branch, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (branch, name) {
	// parse text into XML tree, recurse for nested nodes
	if (!branch) branch = this.tree;
	if (!name) name = null;
	var foundClosing = false;
	var matches = null;
	
	// match each tag, plus preceding text
	while ( matches = this.patTag.exec(this.text) ) {
		var before = matches[1];
		var tag = matches[2];
		
		// text leading up to tag = content of parent node
		if (before.match(/\S/)) {
			if (typeof(branch[this.dataKey]) != &#x27;undefined&#x27;) branch[this.dataKey] += &#x27; &#x27;; else branch[this.dataKey] = &#x27;&#x27;;
			branch[this.dataKey] += trim(decode_entities(before));
		}
		
		// parse based on tag type
		if (tag.match(this.patSpecialTag)) {
			// special tag
			if (tag.match(this.patPITag)) tag = this.parsePINode(tag);
			else if (tag.match(this.patCommentTag)) tag = this.parseCommentNode(tag);
			else if (tag.match(this.patDTDTag)) tag = this.parseDTDNode(tag);
			else if (tag.match(this.patCDATATag)) {
				tag = this.parseCDATANode(tag);
				if (typeof(branch[this.dataKey]) != &#x27;undefined&#x27;) branch[this.dataKey] += &#x27; &#x27;; else branch[this.dataKey] = &#x27;&#x27;;
				branch[this.dataKey] += trim(decode_entities(tag));
			} // cdata
			else {
				this.throwParseError( &#x22;Malformed special tag&#x22;, tag );
				break;
			} // error
			
			if (tag == null) break;
			continue;
		} // special tag
		else {
			// Tag is standard, so parse name and attributes (if any)
			var matches = tag.match(this.patStandardTag);
			if (!matches) {
				this.throwParseError( &#x22;Malformed tag&#x22;, tag );
				break;
			}
			
			var closing = matches[1];
			var nodeName = this.lowerCase ? matches[2].toLowerCase() : matches[2];
			var attribsRaw = matches[3];
			
			// If this is a closing tag, make sure it matches its opening tag
			if (closing) {
				if (nodeName == (name || &#x27;&#x27;)) {
					foundClosing = 1;
					break;
				}
				else {
					this.throwParseError( &#x22;Mismatched closing tag (expected &#x3c;/&#x22; + name + &#x22;&#x3e;)&#x22;, tag );
					break;
				}
			} // closing tag
			else {
				// Not a closing tag, so parse attributes into hash.  If tag
				// is self-closing, no recursive parsing is needed.
				var selfClosing = !!attribsRaw.match(this.patSelfClosing);
				var leaf = {};
				var attribs = leaf;
				
				// preserve attributes means they go into a sub-hash named &#x22;_Attribs&#x22;
				// the XML composer honors this for restoring the tree back into XML
				if (this.preserveAttributes) {
					leaf[this.attribsKey] = {};
					attribs = leaf[this.attribsKey];
				}
				
				// parse attributes
				this.patAttrib.lastIndex = 0;
				while ( matches = this.patAttrib.exec(attribsRaw) ) {
					var key = this.lowerCase ? matches[1].toLowerCase() : matches[1];
					attribs[ key ] = decode_entities( matches[3] );
				} // foreach attrib
				
				// if no attribs found, but we created the _Attribs subhash, clean it up now
				if (this.preserveAttributes &#x26;&#x26; !num_keys(attribs)) {
					delete leaf[this.attribsKey];
				}
				
				// Recurse for nested nodes
				if (!selfClosing) {
					this.parse( leaf, nodeName );
					if (this.error()) break;
				}
				
				// Compress into simple node if text only
				var num_leaf_keys = num_keys(leaf);
				if ((typeof(leaf[this.dataKey]) != &#x27;undefined&#x27;) &#x26;&#x26; (num_leaf_keys == 1)) {
					leaf = leaf[this.dataKey];
				}
				else if (!num_leaf_keys) {
					leaf = &#x27;&#x27;;
				}
				
				// Add leaf to parent branch
				if (typeof(branch[nodeName]) != &#x27;undefined&#x27;) {
					if (isa_array(branch[nodeName])) {
						branch[nodeName].push( leaf );
					}
					else {
						var temp = branch[nodeName];
						branch[nodeName] = [ temp, leaf ];
					}
				}
				else {
					branch[nodeName] = leaf;
				}
				
				if (this.error() || (branch == this.tree)) break;
			} // not closing
		} // standard tag
	} // main reg exp
	
	// Make sure we found the closing tag
	if (name &#x26;&#x26; !foundClosing) {
		this.throwParseError( &#x22;Missing closing tag (expected &#x3c;/&#x22; + name + &#x22;&#x3e;)&#x22;, name );
	}
	
	// If we are the master node, finish parsing and setup our doc node
	if (branch == this.tree) {
		if (typeof(this.tree[this.dataKey]) != &#x27;undefined&#x27;) delete this.tree[this.dataKey];
		
		if (num_ke ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

```javascript
var XML = require(&#x27;pixl-xml&#x27;);
```

# Simplified API

The simplified API provides basic `XML.<span class="apidocCodeKeywordSpan">parse</span>()` and `XML.stringify()` standalone functions
 for parsing and serializing XML.  Also see the [Object-Oriented API](#object-oriented-api) below, for more control over your XML
.

Parse some XML by passing a string to `XML.parse()`:

```javascript
var xml_string = &#x27;&#x3c;?xml version=&#x22;1.0&#x22;?&#x3e;&#x3c;Document&#x3e;&#x27; +
	&#x27;&#x3c;Simple&#x3e;Hello&#x3c;/Simple&#x3e;&#x27; +
	&#x27;&#x3c;Node Key=&#x22;Value&#x22;&#x3e;Complex&#x3c;/Node&#x3e;&#x27; +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.parseCDATANode" id="apidoc.element.pixl-xml.Parser.prototype.parseCDATANode">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parseCDATANode
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCDATANode = function (tag) {
	// Parse CDATA Node, e.g. &#x3c;![CDATA[Brooks &#x26; Shields]]&#x3e;
	var matches = null;
	this.patNextClose.lastIndex = this.patTag.lastIndex;
	
	while (!tag.match(this.patEndCDATA)) {
		if (matches = this.patNextClose.exec(this.text)) {
			tag += &#x27;&#x3e;&#x27; + matches[1];
		}
		else {
			this.throwParseError( &#x22;Unclosed CDATA tag&#x22;, tag );
			return null;
		}
	}
	
	this.patTag.lastIndex = this.patNextClose.lastIndex;
	
	if (matches = tag.match(this.patCDATANode)) {
		return matches[1];
	}
	else {
		this.throwParseError( &#x22;Malformed CDATA tag&#x22;, tag );
		return null;
	}
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		// parse based on tag type
		if (tag.match(this.patSpecialTag)) {
			// special tag
			if (tag.match(this.patPITag)) tag = this.parsePINode(tag);
			else if (tag.match(this.patCommentTag)) tag = this.parseCommentNode(tag);
			else if (tag.match(this.patDTDTag)) tag = this.parseDTDNode(tag);
			else if (tag.match(this.patCDATATag)) {
				tag = this.<span class="apidocCodeKeywordSpan">parseCDATANode</span>(tag);
				if (typeof(branch[this.dataKey]) != &#x27;undefined&#x27;) branch[this.dataKey] += &#x27; &#x27;; else branch[this.dataKey] = &#
x27;&#x27;;
				branch[this.dataKey] += trim(decode_entities(tag));
			} // cdata
			else {
				this.throwParseError( &#x22;Malformed special tag&#x22;, tag );
				break;
			} // error
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.parseCommentNode" id="apidoc.element.pixl-xml.Parser.prototype.parseCommentNode">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parseCommentNode
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseCommentNode = function (tag) {
	// Parse Comment Node, e.g. &#x3c;!-- hello --&#x3e;
	var matches = null;
	this.patNextClose.lastIndex = this.patTag.lastIndex;
	
	while (!tag.match(this.patEndComment)) {
		if (matches = this.patNextClose.exec(this.text)) {
			tag += &#x27;&#x3e;&#x27; + matches[1];
		}
		else {
			this.throwParseError( &#x22;Unclosed comment tag&#x22;, tag );
			return null;
		}
	}
	
	this.patTag.lastIndex = this.patNextClose.lastIndex;
	return tag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			branch[this.dataKey] += trim(decode_entities(before));
		}
		
		// parse based on tag type
		if (tag.match(this.patSpecialTag)) {
			// special tag
			if (tag.match(this.patPITag)) tag = this.parsePINode(tag);
			else if (tag.match(this.patCommentTag)) tag = this.<span class="apidocCodeKeywordSpan">parseCommentNode</span>(tag);
			else if (tag.match(this.patDTDTag)) tag = this.parseDTDNode(tag);
			else if (tag.match(this.patCDATATag)) {
				tag = this.parseCDATANode(tag);
				if (typeof(branch[this.dataKey]) != &#x27;undefined&#x27;) branch[this.dataKey] += &#x27; &#x27;; else branch[this.dataKey] = &#
x27;&#x27;;
				branch[this.dataKey] += trim(decode_entities(tag));
			} // cdata
			else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.parseDTDNode" id="apidoc.element.pixl-xml.Parser.prototype.parseDTDNode">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parseDTDNode
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseDTDNode = function (tag) {
	// Parse Document Type Descriptor Node, e.g. &#x3c;!DOCTYPE ... &#x3e;
	var matches = null;
	
	if (tag.match(this.patExternalDTDNode)) {
		// tag is external, and thus self-closing
		this.dtdNodeList.push( tag );
	}
	else if (tag.match(this.patInlineDTDNode)) {
		// Tag is inline, so check for nested nodes.
		this.patNextClose.lastIndex = this.patTag.lastIndex;
		
		while (!tag.match(this.patEndDTD)) {
			if (matches = this.patNextClose.exec(this.text)) {
				tag += &#x27;&#x3e;&#x27; + matches[1];
			}
			else {
				this.throwParseError( &#x22;Unclosed DTD tag&#x22;, tag );
				return null;
			}
		}
		
		this.patTag.lastIndex = this.patNextClose.lastIndex;
		
		// Make sure complete tag is well-formed, and push onto DTD stack.
		if (tag.match(this.patDTDNode)) {
			this.dtdNodeList.push( tag );
		}
		else {
			this.throwParseError( &#x22;Malformed DTD tag&#x22;, tag );
			return null;
		}
	}
	else {
		this.throwParseError( &#x22;Malformed DTD tag&#x22;, tag );
		return null;
	}
	
	return tag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
		}
		
		// parse based on tag type
		if (tag.match(this.patSpecialTag)) {
			// special tag
			if (tag.match(this.patPITag)) tag = this.parsePINode(tag);
			else if (tag.match(this.patCommentTag)) tag = this.parseCommentNode(tag);
			else if (tag.match(this.patDTDTag)) tag = this.<span class="apidocCodeKeywordSpan">parseDTDNode</span>(tag);
			else if (tag.match(this.patCDATATag)) {
				tag = this.parseCDATANode(tag);
				if (typeof(branch[this.dataKey]) != &#x27;undefined&#x27;) branch[this.dataKey] += &#x27; &#x27;; else branch[this.dataKey] = &#
x27;&#x27;;
				branch[this.dataKey] += trim(decode_entities(tag));
			} // cdata
			else {
				this.throwParseError( &#x22;Malformed special tag&#x22;, tag );
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.parsePINode" id="apidoc.element.pixl-xml.Parser.prototype.parsePINode">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>parsePINode
        <span class="apidocSignatureSpan">(tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parsePINode = function (tag) {
	// Parse Processor Instruction Node, e.g. &#x3c;?xml version=&#x22;1.0&#x22;?&#x3e;
	if (!tag.match(this.patPINode)) {
		this.throwParseError( &#x22;Malformed processor instruction&#x22;, tag );
		return null;
	}
	
	this.piNodeList.push( tag );
	return tag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			if (typeof(branch[this.dataKey]) != &#x27;undefined&#x27;) branch[this.dataKey] += &#x27; &#x27;; else branch[this.dataKey] = &#
x27;&#x27;;
			branch[this.dataKey] += trim(decode_entities(before));
		}
		
		// parse based on tag type
		if (tag.match(this.patSpecialTag)) {
			// special tag
			if (tag.match(this.patPITag)) tag = this.<span class="apidocCodeKeywordSpan">parsePINode</span>(tag);
			else if (tag.match(this.patCommentTag)) tag = this.parseCommentNode(tag);
			else if (tag.match(this.patDTDTag)) tag = this.parseDTDNode(tag);
			else if (tag.match(this.patCDATATag)) {
				tag = this.parseCDATANode(tag);
				if (typeof(branch[this.dataKey]) != &#x27;undefined&#x27;) branch[this.dataKey] += &#x27; &#x27;; else branch[this.dataKey] = &#
x27;&#x27;;
				branch[this.dataKey] += trim(decode_entities(tag));
			} // cdata
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pixl-xml.Parser.prototype.throwParseError" id="apidoc.element.pixl-xml.Parser.prototype.throwParseError">
        function <span class="apidocSignatureSpan">pixl-xml.Parser.prototype.</span>throwParseError
        <span class="apidocSignatureSpan">(key, tag)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throwParseError = function (key, tag) {
	// log error and locate current line number in source XML document
	var parsedSource = this.text.substring(0, this.patTag.lastIndex);
	var eolMatch = parsedSource.match(/\n/g);
	var lineNum = (eolMatch ? eolMatch.length : 0) + 1;
	lineNum -= tag.match(/\n/) ? tag.match(/\n/g).length : 0;
	
	this.errors.push({
		type: &#x27;Parse&#x27;,
		key: key,
		text: &#x27;&#x3c;&#x27; + tag + &#x27;&#x3e;&#x27;,
		line: lineNum
	});
	
	// Throw actual error (must wrap parse in try/catch)
	throw new Error( this.getLastError() );
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
			else if (tag.match(this.patDTDTag)) tag = this.parseDTDNode(tag);
			else if (tag.match(this.patCDATATag)) {
				tag = this.parseCDATANode(tag);
				if (typeof(branch[this.dataKey]) != &#x27;undefined&#x27;) branch[this.dataKey] += &#x27; &#x27;; else branch[this.dataKey] = &#
x27;&#x27;;
				branch[this.dataKey] += trim(decode_entities(tag));
			} // cdata
			else {
				this.<span class="apidocCodeKeywordSpan">throwParseError</span>( &#x22;Malformed special tag&#x22;, tag );
				break;
			} // error
			
			if (tag == null) break;
			continue;
		} // special tag
		else {
...</pre></li>
    </ul>










































</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
